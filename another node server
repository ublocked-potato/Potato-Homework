import express from 'express';
import cors from 'cors';
import { spawn } from 'child_process';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = process.env.PORT || 3000;
const RUST_PORT = process.env.RUST_PORT || 8080;
const PYTHON_PORT = process.env.PYTHON_PORT || 5000;
const EVASION_PORT = process.env.EVASION_PORT || 5001;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static('public'));

// Serve shadow worker
app.get('/shadow-worker.js', (req, res) => {
  res.sendFile(path.join(__dirname, 'shadow-worker.js'));
});

// Health check for all services
const serviceHealth = {
  node: true,
  rust: false,
  python: false,
  evasion: false,
};

// Check Rust service
async function checkRustHealth() {
  try {
    const response = await fetch(`http://localhost:${RUST_PORT}/api/health`);
    serviceHealth.rust = response.ok;
  } catch (error) {
    serviceHealth.rust = false;
  }
}

// Check Python service (advanced parsing fallback)
async function checkPythonHealth() {
  try {
    const response = await fetch(`http://localhost:${PYTHON_PORT}/api/health`);
    serviceHealth.python = response.ok;
  } catch (error) {
    serviceHealth.python = false;
  }
}

// Check Evasion service
async function checkEvasionHealth() {
  try {
    const response = await fetch(`http://localhost:${EVASION_PORT}/api/health`);
    serviceHealth.evasion = response.ok;
  } catch (error) {
    serviceHealth.evasion = false;
  }
}

// Initial health checks
setInterval(checkRustHealth, 10000); // Every 10s
setInterval(checkPythonHealth, 10000);
setInterval(checkEvasionHealth, 10000);
checkRustHealth();
checkPythonHealth();
checkEvasionHealth();

// Proxy all evasion requests
app.all('/api/scramble', async (req, res) => {
  if (!serviceHealth.evasion) {
    return res.status(503).json({ error: 'Evasion service unavailable' });
  }
  
  try {
    const response = await fetch(`http://localhost:${EVASION_PORT}/api/scramble`, {
      method: req.method,
      headers: { 'Content-Type': 'application/json' },
      body: req.method === 'POST' ? JSON.stringify(req.body) : undefined,
    });
    
    const data = await response.json();
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.all('/api/check-domain', async (req, res) => {
  if (!serviceHealth.evasion) {
    return res.json({ healthy: true, burned: false, mirrors: [] });
  }
  
  try {
    const response = await fetch(`http://localhost:${EVASION_PORT}/api/check-domain`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(req.body),
    });
    
    const data = await response.json();
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

app.all('/api/report-block', async (req, res) => {
  if (!serviceHealth.evasion) {
    return res.status(503).json({ error: 'Evasion service unavailable' });
  }
  
  try {
    const response = await fetch(`http://localhost:${EVASION_PORT}/api/report-block`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(req.body),
    });
    
    const data = await response.json();
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Smart routing: Rust (hot path) ‚Üí Python (fallback) ‚Üí Node.js (CORS fallback)
app.all('/api/search', async (req, res) => {
  const query = req.body.q || req.query.q;
  const engine = req.body.engine || req.query.engine || 'duckduckgo';

  console.log(`üîç Search request: "${query}" via ${engine}`);

  // Try Rust first (fastest - hot path)
  if (serviceHealth.rust) {
    try {
      console.log('‚ö° Routing to Rust hot path...');
      const rustResponse = await fetch(`http://localhost:${RUST_PORT}/api/search`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ q: query, engine }),
      });

      if (rustResponse.ok) {
        const data = await rustResponse.json();
        console.log(`‚úÖ Rust returned ${data.total_count} results in hot path`);
        return res.json(data);
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Rust hot path failed, falling back...', error.message);
      serviceHealth.rust = false;
    }
  }

  // Fallback to Python (advanced parsing)
  if (serviceHealth.python) {
    try {
      console.log('üêç Routing to Python fallback...');
      const pythonResponse = await fetch(`http://localhost:${PYTHON_PORT}/api/search`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ q: query, engine }),
      });

      if (pythonResponse.ok) {
        const data = await pythonResponse.json();
        console.log(`‚úÖ Python returned ${data.total_count} results`);
        return res.json(data);
      }
    } catch (error) {
      console.warn('‚ö†Ô∏è Python fallback failed', error.message);
      serviceHealth.python = false;
    }
  }

  // Final fallback: Node.js CORS proxy (slowest but most reliable)
  console.log('üåê Using Node.js CORS fallback...');
  try {
    const corsProxies = [
      'https://api.allorigins.win/raw?url=',
      'https://corsproxy.io/?',
    ];

    let searchUrl = '';
    switch (engine) {
      case 'duckduckgo':
        searchUrl = `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}`;
        break;
      case 'google':
        searchUrl = `https://www.google.com/search?q=${encodeURIComponent(query)}&num=20`;
        break;
      case 'brave':
        searchUrl = `https://search.brave.com/search?q=${encodeURIComponent(query)}`;
        break;
      default:
        searchUrl = `https://html.duckduckgo.com/html/?q=${encodeURIComponent(query)}`;
    }

    const proxyUrl = corsProxies[0] + encodeURIComponent(searchUrl);
    const response = await fetch(proxyUrl);
    const html = await response.text();

    // Basic parsing (Node.js is slower at this, but works)
    const results = basicParseResults(html, engine);

    res.json({
      success: true,
      query,
      engine,
      results,
      total_count: results.length,
      method: 'node-cors-fallback',
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    console.error('‚ùå All search methods failed:', error.message);
    res.status(500).json({
      success: false,
      error: 'All search methods failed',
      message: error.message,
    });
  }
});

// Basic HTML parsing (slower than Rust but works)
function basicParseResults(html, engine) {
  const results = [];
  
  if (engine === 'duckduckgo') {
    // Very basic regex parsing (Rust does this 100x faster)
    const resultRegex = /<a[^>]*class="result__a"[^>]*href="([^"]*)"[^>]*>([^<]*)<\/a>/g;
    let match;
    
    while ((match = resultRegex.exec(html)) !== null && results.length < 20) {
      let url = match[1];
      
      // Extract real URL from DDG redirect
      const uddgMatch = url.match(/uddg=([^&]+)/);
      if (uddgMatch) {
        url = decodeURIComponent(uddgMatch[1]);
      }
      
      results.push({
        title: match[2].trim(),
        url: url,
        display_url: new URL(url).hostname.replace('www.', ''),
        snippet: '',
        relevance_score: 0,
        is_instant: false,
      });
    }
  }
  
  return results;
}

// Proxy endpoint
app.get('/api/proxy', async (req, res) => {
  try {
    const url = Buffer.from(req.query.url, 'base64').toString('utf-8');
    
    const response = await fetch(url, {
      headers: {
        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
      },
    });
    
    const content = await response.text();
    res.send(content);
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Health endpoint
app.get('/api/health', (req, res) => {
  res.json({
    status: 'healthy',
    service: 'omnisearch-node',
    version: '24.13.x',
    backends: serviceHealth,
    timestamp: new Date().toISOString(),
  });
});

// Start server
app.listen(PORT, () => {
  console.log(`
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë  üöÄ OmniSearch Hybrid Backend Running         ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  üì° Node.js:   http://localhost:${PORT}        ‚ïë
‚ïë  ü¶Ä Rust:      http://localhost:${RUST_PORT} (hot path)     ‚ïë
‚ïë  üêç Python:    http://localhost:${PYTHON_PORT} (fallback)    ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë  Architecture:                                ‚ïë
‚ïë  1Ô∏è‚É£  Rust ‚Üí Ultra-fast parallel scraping      ‚ïë
‚ïë  2Ô∏è‚É£  Python ‚Üí Advanced parsing fallback       ‚ïë
‚ïë  3Ô∏è‚É£  Node.js ‚Üí CORS proxy final fallback      ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
  `);
  
  console.log('üîç Checking backend services...');
  checkRustHealth();
  checkPythonHealth();
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('üõë Shutting down gracefully...');
  process.exit(0);
});
